src/RegisterBank.h:37:20: style:inconclusive: The member function 'gbx::RegisterBank::ReadFlag' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
    inline uint8_t ReadFlag(interfaces::Flag flag)
                   ^
src/GameBoyX.cc:10:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '_cpu' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    _cpu = make_shared<Z80X>();
    ^
src/GameBoyX.cc:11:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '_controlUnit' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    _controlUnit = make_shared<ControlUnit>();
    ^
src/GameBoyX.cc:12:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '_memoryController' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    _memoryController = make_shared<MemoryController>();
    ^
src/GameBoyX.cc:13:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '_systemROM' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    _systemROM = make_shared<ROM>(0x1000); // sample rom size
    ^
src/GameBoyX.cc:14:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '_alu' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    _alu = make_shared<ArithmeticLogicUnit>();
    ^
src/GameBoyX.cc:15:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '_clock' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    _clock = make_shared<Clock>(EngineParameters::GBCClockPeriod);
    ^
src/GameBoyX.cc:16:5: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning '_registers' a value by passing the value to the constructor in the initialization list. [useInitializationList]
    _registers = make_shared<RegisterBank>();
    ^
src/ROM.h:20:5: style: Class 'ROM' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    ROM(std::size_t);
    ^
src/instructions/InstructionAdc.h:19:10: performance:inconclusive: The member function 'gbx::InstructionAdc::DecodeAddRegisterMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    void DecodeAddRegisterMode(uint8_t, interfaces::DecodedInstruction&);
         ^
src/instructions/InstructionAdc.cc:30:22: note: Technically the member function 'gbx::InstructionAdc::DecodeAddRegisterMode' can be static (but you may consider moving to unnamed namespace).
void InstructionAdc::DecodeAddRegisterMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                     ^
src/instructions/InstructionAdc.h:19:10: note: Technically the member function 'gbx::InstructionAdc::DecodeAddRegisterMode' can be static (but you may consider moving to unnamed namespace).
    void DecodeAddRegisterMode(uint8_t, interfaces::DecodedInstruction&);
         ^
src/instructions/InstructionAdc.h:20:10: performance:inconclusive: The member function 'gbx::InstructionAdc::DecodeAddImmediateMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    void DecodeAddImmediateMode(interfaces::DecodedInstruction&);
         ^
src/instructions/InstructionAdc.cc:48:22: note: Technically the member function 'gbx::InstructionAdc::DecodeAddImmediateMode' can be static (but you may consider moving to unnamed namespace).
void InstructionAdc::DecodeAddImmediateMode(interfaces::DecodedInstruction& decodedInstruction)
                     ^
src/instructions/InstructionAdc.h:20:10: note: Technically the member function 'gbx::InstructionAdc::DecodeAddImmediateMode' can be static (but you may consider moving to unnamed namespace).
    void DecodeAddImmediateMode(interfaces::DecodedInstruction&);
         ^
src/instructions/InstructionAdc.h:21:10: performance:inconclusive: The member function 'gbx::InstructionAdc::DecodeAddRegisterIndirectMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    void DecodeAddRegisterIndirectMode(interfaces::DecodedInstruction&);
         ^
src/instructions/InstructionAdc.cc:65:22: note: Technically the member function 'gbx::InstructionAdc::DecodeAddRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
void InstructionAdc::DecodeAddRegisterIndirectMode(interfaces::DecodedInstruction& decodedInstruction)
                     ^
src/instructions/InstructionAdc.h:21:10: note: Technically the member function 'gbx::InstructionAdc::DecodeAddRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
    void DecodeAddRegisterIndirectMode(interfaces::DecodedInstruction&);
         ^
src/instructions/InstructionAdd.h:25:17: performance:inconclusive: The member function 'gbx::InstructionAdd::DecodeAddPointerMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeAddPointerMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionAdd.cc:134:29: note: Technically the member function 'gbx::InstructionAdd::DecodeAddPointerMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionAdd::DecodeAddPointerMode(interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionAdd.h:25:17: note: Technically the member function 'gbx::InstructionAdd::DecodeAddPointerMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeAddPointerMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionAddBase.h:27:14: performance:inconclusive: The member function 'gbx::InstructionAddBase::DecideFlagMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    FlagMode DecideFlagMode(interfaces::DecodedInstruction&);
             ^
src/instructions/InstructionAddBase.cc:73:30: note: Technically the member function 'gbx::InstructionAddBase::DecideFlagMode' can be static (but you may consider moving to unnamed namespace).
FlagMode InstructionAddBase::DecideFlagMode(interfaces::DecodedInstruction& decodedInstruction)
                             ^
src/instructions/InstructionAddBase.h:27:14: note: Technically the member function 'gbx::InstructionAddBase::DecideFlagMode' can be static (but you may consider moving to unnamed namespace).
    FlagMode DecideFlagMode(interfaces::DecodedInstruction&);
             ^
src/instructions/InstructionAddBase.cc:73:77: style: Parameter 'decodedInstruction' can be declared with const [constParameter]
FlagMode InstructionAddBase::DecideFlagMode(interfaces::DecodedInstruction& decodedInstruction)
                                                                            ^
src/instructions/InstructionBit.h:18:17: performance:inconclusive: The member function 'gbx::InstructionBit::DecodeBitRegisterMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeBitRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionBit.cc:32:29: note: Technically the member function 'gbx::InstructionBit::DecodeBitRegisterMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionBit::DecodeBitRegisterMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionBit.h:18:17: note: Technically the member function 'gbx::InstructionBit::DecodeBitRegisterMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeBitRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionBit.h:19:17: performance:inconclusive: The member function 'gbx::InstructionBit::DecodeBitRegisterIndirectMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeBitRegisterIndirectMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionBit.cc:52:29: note: Technically the member function 'gbx::InstructionBit::DecodeBitRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionBit::DecodeBitRegisterIndirectMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionBit.h:19:17: note: Technically the member function 'gbx::InstructionBit::DecodeBitRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeBitRegisterIndirectMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionCall.h:18:17: performance:inconclusive: The member function 'gbx::InstructionCall::DecodeUnconditionalCall' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeUnconditionalCall(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionCall.cc:50:30: note: Technically the member function 'gbx::InstructionCall::DecodeUnconditionalCall' can be static (but you may consider moving to unnamed namespace).
inline void InstructionCall::DecodeUnconditionalCall(interfaces::DecodedInstruction& decodedInstruction)
                             ^
src/instructions/InstructionCall.h:18:17: note: Technically the member function 'gbx::InstructionCall::DecodeUnconditionalCall' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeUnconditionalCall(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionCall.h:19:17: performance:inconclusive: The member function 'gbx::InstructionCall::DecodeConditionalCall' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeConditionalCall(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionCall.cc:67:30: note: Technically the member function 'gbx::InstructionCall::DecodeConditionalCall' can be static (but you may consider moving to unnamed namespace).
inline void InstructionCall::DecodeConditionalCall(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                             ^
src/instructions/InstructionCall.h:19:17: note: Technically the member function 'gbx::InstructionCall::DecodeConditionalCall' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeConditionalCall(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionCall.h:20:17: performance:inconclusive: The member function 'gbx::InstructionCall::ExecuteUnconditionalCall' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline bool ExecuteUnconditionalCall(std::shared_ptr<interfaces::RegisterBankInterface>, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionCall.cc:25:30: note: Technically the member function 'gbx::InstructionCall::ExecuteUnconditionalCall' can be static (but you may consider moving to unnamed namespace).
inline bool InstructionCall::ExecuteUnconditionalCall(std::shared_ptr<interfaces::RegisterBankInterface> registerBank, interfaces::DecodedInstruction& decodedInstruction)
                             ^
src/instructions/InstructionCall.h:20:17: note: Technically the member function 'gbx::InstructionCall::ExecuteUnconditionalCall' can be static (but you may consider moving to unnamed namespace).
    inline bool ExecuteUnconditionalCall(std::shared_ptr<interfaces::RegisterBankInterface>, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJp.h:18:17: performance:inconclusive: The member function 'gbx::InstructionJp::DecodeUnconditionalJpRegisterIndirect' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeUnconditionalJpRegisterIndirect(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJp.cc:72:21: note: Technically the member function 'gbx::InstructionJp::DecodeUnconditionalJpRegisterIndirect' can be static (but you may consider moving to unnamed namespace).
void InstructionJp::DecodeUnconditionalJpRegisterIndirect(interfaces::DecodedInstruction& decodedInstruction)
                    ^
src/instructions/InstructionJp.h:18:17: note: Technically the member function 'gbx::InstructionJp::DecodeUnconditionalJpRegisterIndirect' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeUnconditionalJpRegisterIndirect(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJp.h:19:17: performance:inconclusive: The member function 'gbx::InstructionJp::DecodeUnconditionalJpImmediate' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeUnconditionalJpImmediate(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJp.cc:55:21: note: Technically the member function 'gbx::InstructionJp::DecodeUnconditionalJpImmediate' can be static (but you may consider moving to unnamed namespace).
void InstructionJp::DecodeUnconditionalJpImmediate(interfaces::DecodedInstruction& decodedInstruction)
                    ^
src/instructions/InstructionJp.h:19:17: note: Technically the member function 'gbx::InstructionJp::DecodeUnconditionalJpImmediate' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeUnconditionalJpImmediate(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJp.h:20:17: performance:inconclusive: The member function 'gbx::InstructionJp::DecodeConditionalJp' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeConditionalJp(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJp.cc:89:21: note: Technically the member function 'gbx::InstructionJp::DecodeConditionalJp' can be static (but you may consider moving to unnamed namespace).
void InstructionJp::DecodeConditionalJp(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                    ^
src/instructions/InstructionJp.h:20:17: note: Technically the member function 'gbx::InstructionJp::DecodeConditionalJp' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeConditionalJp(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJp.h:21:17: performance:inconclusive: The member function 'gbx::InstructionJp::ExecuteUnconditionalJp' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void ExecuteUnconditionalJp(std::shared_ptr<interfaces::RegisterBankInterface>, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJp.cc:41:21: note: Technically the member function 'gbx::InstructionJp::ExecuteUnconditionalJp' can be static (but you may consider moving to unnamed namespace).
void InstructionJp::ExecuteUnconditionalJp(std::shared_ptr<interfaces::RegisterBankInterface> registerBank, interfaces::DecodedInstruction& decodedInstruction)
                    ^
src/instructions/InstructionJp.h:21:17: note: Technically the member function 'gbx::InstructionJp::ExecuteUnconditionalJp' can be static (but you may consider moving to unnamed namespace).
    inline void ExecuteUnconditionalJp(std::shared_ptr<interfaces::RegisterBankInterface>, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJp.h:22:17: performance:inconclusive: The member function 'gbx::InstructionJp::ExecuteUnconditionalJpRegisterIndirect' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void ExecuteUnconditionalJpRegisterIndirect(std::shared_ptr<interfaces::RegisterBankInterface>, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJp.cc:48:21: note: Technically the member function 'gbx::InstructionJp::ExecuteUnconditionalJpRegisterIndirect' can be static (but you may consider moving to unnamed namespace).
void InstructionJp::ExecuteUnconditionalJpRegisterIndirect(std::shared_ptr<interfaces::RegisterBankInterface> registerBank, interfaces::DecodedInstruction& decodedInstruction)
                    ^
src/instructions/InstructionJp.h:22:17: note: Technically the member function 'gbx::InstructionJp::ExecuteUnconditionalJpRegisterIndirect' can be static (but you may consider moving to unnamed namespace).
    inline void ExecuteUnconditionalJpRegisterIndirect(std::shared_ptr<interfaces::RegisterBankInterface>, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJp.cc:41:141: style: Parameter 'decodedInstruction' can be declared with const [constParameter]
void InstructionJp::ExecuteUnconditionalJp(std::shared_ptr<interfaces::RegisterBankInterface> registerBank, interfaces::DecodedInstruction& decodedInstruction)
                                                                                                                                            ^
src/instructions/InstructionJp.cc:48:157: style: Parameter 'decodedInstruction' can be declared with const [constParameter]
void InstructionJp::ExecuteUnconditionalJpRegisterIndirect(std::shared_ptr<interfaces::RegisterBankInterface> registerBank, interfaces::DecodedInstruction& decodedInstruction)
                                                                                                                                                            ^
src/instructions/InstructionJr.h:18:17: performance:inconclusive: The member function 'gbx::InstructionJr::DecodeUnconditionalJr' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeUnconditionalJr(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJr.cc:43:28: note: Technically the member function 'gbx::InstructionJr::DecodeUnconditionalJr' can be static (but you may consider moving to unnamed namespace).
inline void InstructionJr::DecodeUnconditionalJr(interfaces::DecodedInstruction& decodedInstruction)
                           ^
src/instructions/InstructionJr.h:18:17: note: Technically the member function 'gbx::InstructionJr::DecodeUnconditionalJr' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeUnconditionalJr(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJr.h:19:17: performance:inconclusive: The member function 'gbx::InstructionJr::DecodeConditionalJr' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeConditionalJr(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJr.cc:60:28: note: Technically the member function 'gbx::InstructionJr::DecodeConditionalJr' can be static (but you may consider moving to unnamed namespace).
inline void InstructionJr::DecodeConditionalJr(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                           ^
src/instructions/InstructionJr.h:19:17: note: Technically the member function 'gbx::InstructionJr::DecodeConditionalJr' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeConditionalJr(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJr.h:20:17: performance:inconclusive: The member function 'gbx::InstructionJr::ExecuteUnconditionalJr' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void ExecuteUnconditionalJr(std::shared_ptr<interfaces::RegisterBankInterface>, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionJr.cc:25:28: note: Technically the member function 'gbx::InstructionJr::ExecuteUnconditionalJr' can be static (but you may consider moving to unnamed namespace).
inline void InstructionJr::ExecuteUnconditionalJr(std::shared_ptr<interfaces::RegisterBankInterface> registerBank, interfaces::DecodedInstruction& decodedInstruction)
                           ^
src/instructions/InstructionJr.h:20:17: note: Technically the member function 'gbx::InstructionJr::ExecuteUnconditionalJr' can be static (but you may consider moving to unnamed namespace).
    inline void ExecuteUnconditionalJr(std::shared_ptr<interfaces::RegisterBankInterface>, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionLd.h:37:17: performance:inconclusive: The member function 'gbx::InstructionLd::DecodeRegisterPairImmediateMove' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeRegisterPairImmediateMove(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionLd.cc:406:28: note: Technically the member function 'gbx::InstructionLd::DecodeRegisterPairImmediateMove' can be static (but you may consider moving to unnamed namespace).
inline void InstructionLd::DecodeRegisterPairImmediateMove(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                           ^
src/instructions/InstructionLd.h:37:17: note: Technically the member function 'gbx::InstructionLd::DecodeRegisterPairImmediateMove' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeRegisterPairImmediateMove(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionLd.h:49:17: performance:inconclusive: The member function 'gbx::InstructionLd::DecodeRegisterIndexedMove' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeRegisterIndexedMove(uint8_t, uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionLd.cc:441:28: note: Technically the member function 'gbx::InstructionLd::DecodeRegisterIndexedMove' can be static (but you may consider moving to unnamed namespace).
inline void InstructionLd::DecodeRegisterIndexedMove(uint8_t opcode, uint8_t preOpcode, interfaces::DecodedInstruction& decodedInstruction)
                           ^
src/instructions/InstructionLd.h:49:17: note: Technically the member function 'gbx::InstructionLd::DecodeRegisterIndexedMove' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeRegisterIndexedMove(uint8_t, uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionLd.h:50:17: performance:inconclusive: The member function 'gbx::InstructionLd::DecodeIndexedRegisterMove' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeIndexedRegisterMove(uint8_t, uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionLd.cc:461:28: note: Technically the member function 'gbx::InstructionLd::DecodeIndexedRegisterMove' can be static (but you may consider moving to unnamed namespace).
inline void InstructionLd::DecodeIndexedRegisterMove(uint8_t opcode, uint8_t preOpcode, interfaces::DecodedInstruction& decodedInstruction)
                           ^
src/instructions/InstructionLd.h:50:17: note: Technically the member function 'gbx::InstructionLd::DecodeIndexedRegisterMove' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeIndexedRegisterMove(uint8_t, uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRes.h:18:17: performance:inconclusive: The member function 'gbx::InstructionRes::DecodeResRegisterMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeResRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRes.cc:41:29: note: Technically the member function 'gbx::InstructionRes::DecodeResRegisterMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionRes::DecodeResRegisterMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionRes.h:18:17: note: Technically the member function 'gbx::InstructionRes::DecodeResRegisterMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeResRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRes.h:19:17: performance:inconclusive: The member function 'gbx::InstructionRes::DecodeResRegisterIndirectMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeResRegisterIndirectMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRes.cc:61:29: note: Technically the member function 'gbx::InstructionRes::DecodeResRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionRes::DecodeResRegisterIndirectMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionRes.h:19:17: note: Technically the member function 'gbx::InstructionRes::DecodeResRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeResRegisterIndirectMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRl.h:18:17: performance:inconclusive: The member function 'gbx::InstructionRl::DecodeRlRegisterMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeRlRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRl.cc:28:28: note: Technically the member function 'gbx::InstructionRl::DecodeRlRegisterMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionRl::DecodeRlRegisterMode(uint8_t complement, interfaces::DecodedInstruction& decodedInstruction)
                           ^
src/instructions/InstructionRl.h:18:17: note: Technically the member function 'gbx::InstructionRl::DecodeRlRegisterMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeRlRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRl.h:19:17: performance:inconclusive: The member function 'gbx::InstructionRl::DecodeRlRegisterIndirectMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeRlRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRl.cc:46:28: note: Technically the member function 'gbx::InstructionRl::DecodeRlRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionRl::DecodeRlRegisterIndirectMode(interfaces::DecodedInstruction& decodedInstruction)
                           ^
src/instructions/InstructionRl.h:19:17: note: Technically the member function 'gbx::InstructionRl::DecodeRlRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeRlRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRlc.h:18:17: performance:inconclusive: The member function 'gbx::InstructionRlc::DecodeRlcRegisterMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeRlcRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRlc.cc:27:29: note: Technically the member function 'gbx::InstructionRlc::DecodeRlcRegisterMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionRlc::DecodeRlcRegisterMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionRlc.h:18:17: note: Technically the member function 'gbx::InstructionRlc::DecodeRlcRegisterMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeRlcRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRlc.h:19:17: performance:inconclusive: The member function 'gbx::InstructionRlc::DecodeRlcRegisterIndirectMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeRlcRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRlc.cc:45:29: note: Technically the member function 'gbx::InstructionRlc::DecodeRlcRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionRlc::DecodeRlcRegisterIndirectMode(interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionRlc.h:19:17: note: Technically the member function 'gbx::InstructionRlc::DecodeRlcRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeRlcRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRr.h:18:17: performance:inconclusive: The member function 'gbx::InstructionRr::DecodeRrRegisterMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeRrRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRr.cc:44:28: note: Technically the member function 'gbx::InstructionRr::DecodeRrRegisterMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionRr::DecodeRrRegisterMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                           ^
src/instructions/InstructionRr.h:18:17: note: Technically the member function 'gbx::InstructionRr::DecodeRrRegisterMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeRrRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRr.h:19:17: performance:inconclusive: The member function 'gbx::InstructionRr::DecodeRrRegisterIndirectMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeRrRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRr.cc:62:28: note: Technically the member function 'gbx::InstructionRr::DecodeRrRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionRr::DecodeRrRegisterIndirectMode(interfaces::DecodedInstruction& decodedInstruction)
                           ^
src/instructions/InstructionRr.h:19:17: note: Technically the member function 'gbx::InstructionRr::DecodeRrRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeRrRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRrc.h:18:17: performance:inconclusive: The member function 'gbx::InstructionRrc::DecodeRrcRegisterMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeRrcRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRrc.cc:43:29: note: Technically the member function 'gbx::InstructionRrc::DecodeRrcRegisterMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionRrc::DecodeRrcRegisterMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionRrc.h:18:17: note: Technically the member function 'gbx::InstructionRrc::DecodeRrcRegisterMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeRrcRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRrc.h:19:17: performance:inconclusive: The member function 'gbx::InstructionRrc::DecodeRrcRegisterIndirectMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeRrcRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRrc.cc:61:29: note: Technically the member function 'gbx::InstructionRrc::DecodeRrcRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionRrc::DecodeRrcRegisterIndirectMode(interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionRrc.h:19:17: note: Technically the member function 'gbx::InstructionRrc::DecodeRrcRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeRrcRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionRst.h:18:13: performance:inconclusive: The member function 'gbx::InstructionRst::GetPageLowerAddress' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    uint8_t GetPageLowerAddress(uint8_t page);
            ^
src/instructions/InstructionRst.cc:40:25: note: Technically the member function 'gbx::InstructionRst::GetPageLowerAddress' can be static (but you may consider moving to unnamed namespace).
uint8_t InstructionRst::GetPageLowerAddress(uint8_t page)
                        ^
src/instructions/InstructionRst.h:18:13: note: Technically the member function 'gbx::InstructionRst::GetPageLowerAddress' can be static (but you may consider moving to unnamed namespace).
    uint8_t GetPageLowerAddress(uint8_t page);
            ^
src/instructions/InstructionSet.h:18:17: performance:inconclusive: The member function 'gbx::InstructionSet::DecodeSetRegisterMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeSetRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSet.cc:41:29: note: Technically the member function 'gbx::InstructionSet::DecodeSetRegisterMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionSet::DecodeSetRegisterMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionSet.h:18:17: note: Technically the member function 'gbx::InstructionSet::DecodeSetRegisterMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeSetRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSet.h:19:17: performance:inconclusive: The member function 'gbx::InstructionSet::DecodeSetRegisterIndirectMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeSetRegisterIndirectMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSet.cc:61:29: note: Technically the member function 'gbx::InstructionSet::DecodeSetRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionSet::DecodeSetRegisterIndirectMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionSet.h:19:17: note: Technically the member function 'gbx::InstructionSet::DecodeSetRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeSetRegisterIndirectMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSla.h:18:17: performance:inconclusive: The member function 'gbx::InstructionSla::DecodeSlaRegisterMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeSlaRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSla.cc:43:29: note: Technically the member function 'gbx::InstructionSla::DecodeSlaRegisterMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionSla::DecodeSlaRegisterMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionSla.h:18:17: note: Technically the member function 'gbx::InstructionSla::DecodeSlaRegisterMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeSlaRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSla.h:19:17: performance:inconclusive: The member function 'gbx::InstructionSla::DecodeSlaRegisterIndirectMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeSlaRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSla.cc:61:29: note: Technically the member function 'gbx::InstructionSla::DecodeSlaRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionSla::DecodeSlaRegisterIndirectMode(interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionSla.h:19:17: note: Technically the member function 'gbx::InstructionSla::DecodeSlaRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeSlaRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSra.h:18:17: performance:inconclusive: The member function 'gbx::InstructionSra::DecodeSraRegisterMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeSraRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSra.cc:44:29: note: Technically the member function 'gbx::InstructionSra::DecodeSraRegisterMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionSra::DecodeSraRegisterMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionSra.h:18:17: note: Technically the member function 'gbx::InstructionSra::DecodeSraRegisterMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeSraRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSra.h:19:17: performance:inconclusive: The member function 'gbx::InstructionSra::DecodeSraRegisterIndirectMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeSraRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSra.cc:62:29: note: Technically the member function 'gbx::InstructionSra::DecodeSraRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionSra::DecodeSraRegisterIndirectMode(interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionSra.h:19:17: note: Technically the member function 'gbx::InstructionSra::DecodeSraRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeSraRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSrl.h:18:17: performance:inconclusive: The member function 'gbx::InstructionSrl::DecodeSrlRegisterMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeSrlRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSrl.cc:43:29: note: Technically the member function 'gbx::InstructionSrl::DecodeSrlRegisterMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionSrl::DecodeSrlRegisterMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionSrl.h:18:17: note: Technically the member function 'gbx::InstructionSrl::DecodeSrlRegisterMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeSrlRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSrl.h:19:17: performance:inconclusive: The member function 'gbx::InstructionSrl::DecodeSrlRegisterIndirectMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeSrlRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSrl.cc:61:29: note: Technically the member function 'gbx::InstructionSrl::DecodeSrlRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionSrl::DecodeSrlRegisterIndirectMode(interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionSrl.h:19:17: note: Technically the member function 'gbx::InstructionSrl::DecodeSrlRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeSrlRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSwap.h:18:17: performance:inconclusive: The member function 'gbx::InstructionSwap::DecodeSwapRegisterMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeSwapRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSwap.cc:43:30: note: Technically the member function 'gbx::InstructionSwap::DecodeSwapRegisterMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionSwap::DecodeSwapRegisterMode(uint8_t opcode, interfaces::DecodedInstruction& decodedInstruction)
                             ^
src/instructions/InstructionSwap.h:18:17: note: Technically the member function 'gbx::InstructionSwap::DecodeSwapRegisterMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeSwapRegisterMode(uint8_t, interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSwap.h:19:17: performance:inconclusive: The member function 'gbx::InstructionSwap::DecodeSwapRegisterIndirectMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeSwapRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionSwap.cc:61:30: note: Technically the member function 'gbx::InstructionSwap::DecodeSwapRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionSwap::DecodeSwapRegisterIndirectMode(interfaces::DecodedInstruction& decodedInstruction)
                             ^
src/instructions/InstructionSwap.h:19:17: note: Technically the member function 'gbx::InstructionSwap::DecodeSwapRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeSwapRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionXor.h:19:17: performance:inconclusive: The member function 'gbx::InstructionXor::DecodeXorImmediateMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeXorImmediateMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionXor.cc:60:29: note: Technically the member function 'gbx::InstructionXor::DecodeXorImmediateMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionXor::DecodeXorImmediateMode(interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionXor.h:19:17: note: Technically the member function 'gbx::InstructionXor::DecodeXorImmediateMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeXorImmediateMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionXor.h:20:17: performance:inconclusive: The member function 'gbx::InstructionXor::DecodeXorRegisterIndirectMode' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
    inline void DecodeXorRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/instructions/InstructionXor.cc:77:29: note: Technically the member function 'gbx::InstructionXor::DecodeXorRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
inline void InstructionXor::DecodeXorRegisterIndirectMode(interfaces::DecodedInstruction& decodedInstruction)
                            ^
src/instructions/InstructionXor.h:20:17: note: Technically the member function 'gbx::InstructionXor::DecodeXorRegisterIndirectMode' can be static (but you may consider moving to unnamed namespace).
    inline void DecodeXorRegisterIndirectMode(interfaces::DecodedInstruction&);
                ^
src/ArithmeticLogicUnit.cc:265:0: style: The function 'ClearInterruptStatusSignal' is never used. [unusedFunction]

^
src/gbx.cc:22:0: style: The function 'GetALU' is never used. [unusedFunction]

^
src/gbx.cc:18:0: style: The function 'GetCPU' is never used. [unusedFunction]

^
src/gbx.cc:23:0: style: The function 'GetClock' is never used. [unusedFunction]

^
src/gbx.cc:19:0: style: The function 'GetControlUnit' is never used. [unusedFunction]

^
src/gbx.cc:20:0: style: The function 'GetMemoryController' is never used. [unusedFunction]

^
src/Clock.cc:16:0: style: The function 'Period' is never used. [unusedFunction]

^
src/RegisterBank.cc:117:0: style: The function 'Swap' is never used. [unusedFunction]

^
src/Clock.cc:26:0: style: The function 'Tick' is never used. [unusedFunction]

^
src/Clock.cc:21:0: style: The function 'Ticks' is never used. [unusedFunction]

^
src/GBXExceptions.cc:40:0: style: The function 'what' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingIncludeSystem]

