src/GBXAsmExceptions.h:12:5: style: Class 'GBXAsmException' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    GBXAsmException(const std::string);
    ^
src/GBXAsmExceptions.h:23:5: style: Class 'LexerException' has a constructor with 1 argument that is not explicit. Such constructors should in general be explicit for type safety reasons. Using the explicit keyword in the constructor means some mistakes when using the class can be avoided. [noExplicitConstructor]
    LexerException(const std::string);
    ^
src/GBXAsmExceptions.cc:8:52: performance: Parameter 'message' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
GBXAsmException::GBXAsmException(const std::string message)
                                                   ^
src/GBXAsmExceptions.cc:12:50: performance: Parameter 'message' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
LexerException::LexerException(const std::string message)
                                                 ^
src/Lexer.cc:60:44: performance: Parameter 'originalLexeme' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
vector<Token> Lexer::EvaluateLexeme(string originalLexeme, size_t column, size_t globalCounter)
                                           ^
src/Lexer.cc:492:48: performance: Parameter 'lexeme' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
inline void Lexer::EvaluateStringLimits(string lexeme, size_t column)
                                               ^
src/Lexer.cc:520:62: performance: Parameter 'candidate' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
inline string Lexer::ExtractOperatorSeparatorOrMarker(string candidate, size_t column)
                                                             ^
src/Lexer.cc:571:61: performance: Parameter 'candidate' is passed by value. It could be passed as a const reference which is usually faster and recommended in C++. [passedByValue]
inline string Lexer::ExtractCharLiteralFromCandidate(string candidate, size_t column)
                                                            ^
src/Lexer.cc:398:9: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
        {
        ^
src/Lexer.cc:410:9: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
        {
        ^
src/Lexer.cc:421:9: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
        {
        ^
src/Lexer.cc:714:0: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
        if (token.Type == TokenType::SeparatorDOUBLEQUOTES)
^
src/Lexer.cc:11:0: style: The function 'Tokens' is never used. [unusedFunction]

^
src/GBXAsmExceptions.cc:17:0: style: The function 'what' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingIncludeSystem]

